/*
Count Palindromic Subsequences
MediumAccuracy: 17.0%Submissions: 114K+Points: 4
Join the most popular course on DSA. Master Skills & Become Employable by enrolling today! 
Given a string str of length N, you have to find number of palindromic subsequence (need not necessarily be distinct) present in the string str.
Note: You have to return the answer module 109+7;
 

Example 1:

Input: 
Str = "abcd"
Output: 
4
Explanation:
palindromic subsequence are : "a" ,"b", "c" ,"d"
 

Example 2:

Input: 
Str = "aab"
Output: 
4
Explanation:
palindromic subsequence are :"a", "a", "b", "aa"
 

Your Task:
You don't need to read input or print anything. Your task is to complete the function countPs() which takes a string str as input parameter and returns the number of palindromic subsequence.
 

Expected Time Complexity: O(N*N)
Expected Auxiliary Space: O(N*N)


Constraints:
1<=length of string str <=1000


*/


/*

SUPPOSE SUBSEQUNCE OF ABCD WE WANT TO MAKE 
LETS MAKE SUBSEQUNCE OF BC
THEY ARE 
BC
B
C
""(EMPTY)

NOW SUBSEQUNCE OF ABCD CAN BE GENERATED BY

FIRST ADD A TO ALL SUBSEQUNCES OF BC 
THEN ADD D TO ALL SUBSEQUNCE OF BC
THEN ADD BOTH A AND D TO ALL SUBSEQUNCESS OF BC 
THEN ADD NOTHING TO ALL SUBSEQUNCE OF BC

THAT S HOW ALL SUBSEQUENCES CAN BE MADE OF BC



*/


#include<bits/stdc++.h>
using namespace std;



class Solution{
    public:
    /*You are required to complete below method */
    long long int  countPS(string str)
    {
        int n=str.length();
       vector<vector<long long int >> dp(n,vector<long long int >(n,0));
       
       for(int i=0;i<n;i++){
           dp[i][i]=1;
           if(i!=n-1){
            if(str[i]==str[i+1]){
                dp[i][i+1]=3;
            }
            else{
                dp[i][i+1]=2;
            }
           }
       }
       int mod=1e9+7;
       
       
       
       for(int d=3;d<=n;d++){
           for(int i=0;i+d<=n;i++){
               int j=i+d-1;
               if(str[i]==str[j]){
                //num of subsequnces in prefix part that is startchar plus middle
                //num of subsequnces in suffix part that is endchar plus middle
                //num of middle bcoz all subsqiecnes will have additional chars added
                // above one will be added automatically as number of middle subsequnceds are added twice
                //one more for only i and j since they also make subsequence
                
                dp[i][j]=(dp[i][j-1]+dp[i+1][j]+1)%mod;
               }
               else{
                   //start part plus end part -middle part as it is included twice
                   dp[i][j]=(dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1])%mod;
                   
                   
               }
               
           }
           
       }
       while(dp[0][n-1]<0){
           dp[0][n-1]+=mod;
       }
       return dp[0][n-1];
    }
     
};